[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The R Stuff",
    "section": "",
    "text": "Select Empty Columns\n\n\n\n\n\n\n\n\n\n\n\n\nRavi Chowdhury\n\n\n\n\n\n\n  \n\n\n\n\nCreate Table Permission in SQL\n\n\n\n\n\n\n\n\n\n\n\n\n\nApr 12, 2023\n\n\nRavi C\n\n\n\n\n\n\n  \n\n\n\n\nReorder columns\n\n\n\n\n\n\n\n\n\n\n\n\nMar 1, 2023\n\n\nRavi C\n\n\n\n\n\n\n  \n\n\n\n\nCreate SQL DB in R\n\n\n\n\n\n\n\n\n\n\n\n\nFeb 28, 2023\n\n\nRavi C\n\n\n\n\n\n\n  \n\n\n\n\nInteract with SQL Server\n\n\n\n\n\n\n\n\n\n\n\n\nFeb 13, 2023\n\n\nRavi C\n\n\n\n\n\n\n  \n\n\n\n\nFilter with str_detect\n\n\n\n\n\n\n\n\n\n\n\n\nJan 25, 2023\n\n\nRavi C\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Ravi Chowdhury",
    "section": "",
    "text": "I am a Research Data Analyst at Northwestern University and work for the Bluhm Cardiovascular Institute at Northwestern Memorial Hospital. I like working with R and try to make peoples life easy by making reproducible reports. I love working on data visualization as well as rmarkdown for reporting. I want to post about various projects and tips that I have learned and still learning to help others."
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "Ravi Chowdhury",
    "section": "Education",
    "text": "Education\nMasters of Public Health (MPH) - Epidemiology & Biostatistics - University of Illinois at Chicago (UIC)"
  },
  {
    "objectID": "about.html#experince",
    "href": "about.html#experince",
    "title": "Ravi Chowdhury",
    "section": "Experince",
    "text": "Experince\nResearch Data Analyst - Northwestern University"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Blog\n\n\n\n\n\n\n\n\n\n\n\n\nSelect Empty Columns\n\n\n\n\n\n\n\n\n\n\n\n\nRavi Chowdhury\n\n\n\n\n\n\n\n\nCreate Table Permission in SQL\n\n\n\n\n\n\n\n\n\n\n\n\n\nApr 12, 2023\n\n\nRavi C\n\n\n\n\n\n\n\n\nReorder columns\n\n\n\n\n\n\n\n\n\n\n\n\nMar 1, 2023\n\n\nRavi C\n\n\n\n\n\n\n\n\nCreate SQL DB in R\n\n\n\n\n\n\n\n\n\n\n\n\nFeb 28, 2023\n\n\nRavi C\n\n\n\n\n\n\n\n\nInteract with SQL Server\n\n\n\n\n\n\n\n\n\n\n\n\nFeb 13, 2023\n\n\nRavi C\n\n\n\n\n\n\n\n\nFilter with str_detect\n\n\n\n\n\n\n\n\n\n\n\n\nJan 25, 2023\n\n\nRavi C\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blog/post-with-code/index.html",
    "href": "blog/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "blog/welcome/index.html",
    "href": "blog/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "Since this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "blog/2023-01-filter_with_str_detect/filter_with_str_detect.html",
    "href": "blog/2023-01-filter_with_str_detect/filter_with_str_detect.html",
    "title": "Filter with str_detect",
    "section": "",
    "text": "To filter using str_detect, generally you can use the code as follows:\n\nstringr::str_detect(\"ravi chowdhury\", \"ravi\")\n\n[1] TRUE\n\n\nas we can see the it returns logical TRUE which means it was able to find the string, however str_detect is case sensitive as seen below:\n\nstringr::str_detect(\"Ravi Chowdhury\", \"ravi\")\n\n[1] FALSE\n\n\nTo fix this we can use regex function ignore_case\n\nstringr::str_detect(\"Ravi Chowdhury\", regex(\"ravi\", ignore_case = TRUE))\n\n[1] TRUE"
  },
  {
    "objectID": "blog/2023-02-sql_server_connect/sql_server_connect.html",
    "href": "blog/2023-02-sql_server_connect/sql_server_connect.html",
    "title": "Interact with SQL Server",
    "section": "",
    "text": "We will go through how to connect to a sql server and fetch tables.\nTo connect to SQL Server, we will use the DBI and ODBC package. Please note you need to create a ODBC connection in Windows using the built in “ODBC Data Source” application.\n\ncon <- DBI::dbConnect(odbc::odbc(), \"db_name\")\n\nOnce the connection is create using the code above you can now use dplyr tbl function to query the tables\n\ntbl(con, \"table_name\")\n\nThe table from tbl is a lazy table and to assign it to tibble or data frame we need the collect function.\n\ntbl_tibble <-\n  tbl(con, \"table_name\") |>\n  collect()\n\nThe above code works fine if your table is under the “dbo” schema, but what if it is on a different schema?\nWe can use the in_schema function from the dbplyr package.\n\ntbl(con, dbplyr::in_schema(\"schema\", \"table_name\"))\n\n\n\n\n\n\n\nWarning\n\n\n\nThere is an issue with nanodbc where NVARCHAR fields are out of bounds for the connection and it wont return a result, I was able to find a solution on stackoverflow here.\n\n\nThe code below will basically arrrange the columns in order and the NVARCHAR fields that have CHARACTER_MAXIMUM_LENGTH = -1 will be replaced with 100000 so that they are at the end of select query.\n\ncol_names <-\n  data_type |>\n  mutate(\n    col_nm = case_when(\n      is.na(CHARACTER_MAXIMUM_LENGTH) ~ 10,\n      CHARACTER_MAXIMUM_LENGTH == -1 ~ 100000,\n      TRUE ~ as.double(CHARACTER_MAXIMUM_LENGTH)\n    )\n  ) |>\n  arrange(col_nm) |>\n  pull(COLUMN_NAME) |>\n  paste(collapse = \", \")\n\nquery <- paste(\"SELECT\", col_names, \"FROM schema.table_name\")\n\ntbl(con, sql(query))"
  },
  {
    "objectID": "blog/2023-02-create_sql_database_in_r/create_sql_database.html",
    "href": "blog/2023-02-create_sql_database_in_r/create_sql_database.html",
    "title": "Create SQL DB in R",
    "section": "",
    "text": "To produce a SQL database, we will utilize the RSQLite and DBI packages and the “iris” data set available in R.\nWe verify that the data set is available for loading.\n\niris |> head()\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\nThen, using the RSQLite and DBI packages, we create a new in-memory database.\n\ncon <- DBI::dbConnect(\n  drv = RSQLite::SQLite(),\n  dbname = \":memory:\"\n  )\n\nNext, we utilize the dbWriteTable function from the DBI package to store the “iris” data set into a SQL table in the in-memory database created in the previous step. As shown in the output, a table named “iris_sql_tbl” is created.\nIn the query below, replace “conn” with your connection name from the previous step, “name” with your preferred name for the SQL table (in this case, it is “iris_sql_tbl”), and “value” with the data set being written to the SQL database.\n\nDBI::dbWriteTable(\n  conn = con,\n  name = \"iris_sql_tbl\",\n  value = iris\n)\n\nDBI::dbListTables(con)\n\n[1] \"iris_sql_tbl\"\n\n\nUsing the tbl function from the tidyverse package, we can execute a query on the newly created SQL database table.\n\ntbl(con, \"iris_sql_tbl\")\n\n# Source:   table<iris_sql_tbl> [?? x 5]\n# Database: sqlite 3.40.0 [:memory:]\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          <dbl>       <dbl>        <dbl>       <dbl> <chr>  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# ... with more rows\n\n\nWe can also run querries using the SQL connection and not have to pull the data in R.\n\ntbl(con, \"iris_sql_tbl\") |>\n  summarize(\n    max_length = max(Sepal.Length, na.rm = TRUE),\n    min_length = min(Sepal.Length, na.rm = TRUE)\n  )\n\n# Source:   SQL [1 x 2]\n# Database: sqlite 3.40.0 [:memory:]\n  max_length min_length\n       <dbl>      <dbl>\n1        7.9        4.3\n\n\nAlternatively, we can use the dbGetQuery function from DBI to execute actual SQL code.\n\n\n\n\n\n\nWarning\n\n\n\nI ran into an issue where the querry was not able to find the column name without double quotes, will update here if I come across an explanation to it. For now, I am adding a \"\" and using “\" to escape it.\n\n\n\nDBI::dbGetQuery(\n  con,\n  \"SELECT\n  MAX(\\\"Sepal.Length\\\") AS max_length,\n  MIN(\\\"Sepal.Length\\\") AS min_length\n  FROM iris_sql_tbl\"\n)\n\n  max_length min_length\n1        7.9        4.3\n\n\nThis approach will assist in generating blog posts with SQL connections without having to connect to a live SQL Server."
  },
  {
    "objectID": "blog/2023-03-reorder_columns/reorder_columns.html",
    "href": "blog/2023-03-reorder_columns/reorder_columns.html",
    "title": "Reorder columns",
    "section": "",
    "text": "There are several methods to change the order of columns in R. While the select function from dplyr is a common way to do it, we will also explore other functions that can be used to rearrange columns.\nTo demonstrate these methods, we will use the “us_rent_income” dataset from the tidyverse package. To rearrange columns using the select function, we can explicitly specify the order in which we want our columns to appear.\n\nus_rent_income |> head()\n\n# A tibble: 6 x 5\n  GEOID NAME    variable estimate   moe\n  <chr> <chr>   <chr>       <dbl> <dbl>\n1 01    Alabama income      24476   136\n2 01    Alabama rent          747     3\n3 02    Alaska  income      32940   508\n4 02    Alaska  rent         1200    13\n5 04    Arizona income      27517   148\n6 04    Arizona rent          972     4\n\n\n\nus_rent_income |>\n  select(GEOID, estimate, moe, NAME, variable) |>\n  head()\n\n# A tibble: 6 x 5\n  GEOID estimate   moe NAME    variable\n  <chr>    <dbl> <dbl> <chr>   <chr>   \n1 01       24476   136 Alabama income  \n2 01         747     3 Alabama rent    \n3 02       32940   508 Alaska  income  \n4 02        1200    13 Alaska  rent    \n5 04       27517   148 Arizona income  \n6 04         972     4 Arizona rent    \n\n\nAlternatively, we can use the everything function from tidyselect to select our preferred order, with the exception of columns that we have explicitly specified.\nWe can shorten this up and little bit using everything from tidyselect, this way we select our prefered order.\n\nGEOID\nestimate\nmoe\neverything else\n\n\nus_rent_income |>\n  select(GEOID, estimate, moe, everything()) |>\n  head()\n\n# A tibble: 6 x 5\n  GEOID estimate   moe NAME    variable\n  <chr>    <dbl> <dbl> <chr>   <chr>   \n1 01       24476   136 Alabama income  \n2 01         747     3 Alabama rent    \n3 02       32940   508 Alaska  income  \n4 02        1200    13 Alaska  rent    \n5 04       27517   148 Arizona income  \n6 04         972     4 Arizona rent    \n\n\nIf we want to select only the numeric columns and rearrange them, we can use the relocate function from dplyr by specifying the location where the selected columns should be placed. In the example given, we move the numeric columns to be after the “GEOID” column.\n\nus_rent_income |>\n  relocate(where(is.numeric), .after = GEOID) |>\n  head()\n\n# A tibble: 6 x 5\n  GEOID estimate   moe NAME    variable\n  <chr>    <dbl> <dbl> <chr>   <chr>   \n1 01       24476   136 Alabama income  \n2 01         747     3 Alabama rent    \n3 02       32940   508 Alaska  income  \n4 02        1200    13 Alaska  rent    \n5 04       27517   148 Arizona income  \n6 04         972     4 Arizona rent"
  },
  {
    "objectID": "blog/2023-04-create_table_permission_sql/create_table_permission_sql.html",
    "href": "blog/2023-04-create_table_permission_sql/create_table_permission_sql.html",
    "title": "Create Table Permission in SQL",
    "section": "",
    "text": "While working on a code that writes data to SQL database, I ran into an issue where R gives me an error as below\n\n\n\n\n\n\nImportant\n\n\n\nError: nanodbc/nanodbc.cpp:1691: 42000: [Microsoft][ODBC SQL Server Driver][SQL Server]CREATE TABLE permission denied in database ‘Database_Name’.\n\n\nThe problem here is that my user does not have the write permission to create tables in the database, since I was creating a new table. To fix this since I have access to the SQL Server and I am a sysadmin as well I can use SSMS (SQL Server Management Studio) or just run the SQL code in R.\nUSE TransitDB\nGO\nGRANT ALTER ON SCHEMA::DBO TO RW_User\nGRANT CREATE TABLE TO RW_User\nGO"
  },
  {
    "objectID": "blog/2023_12_12_select_empty_column'/select_empty_columns.html",
    "href": "blog/2023_12_12_select_empty_column'/select_empty_columns.html",
    "title": "Select Empty Columns",
    "section": "",
    "text": "This post is about selecting empty columns using R and tidyverse, specifically dplyr. There might be a need where you want to select only empty columns from a table for quality check. For example you expect a column to have data and if the column is empty in the table you can perform checks.\nWith the janitor package, using the remove_empty function, you can remove empty columns but I am not sure if you can get a list of columns that are empty or have no data."
  },
  {
    "objectID": "blog/2023_12_12_select_empty_column'/select_empty_columns.html#load-packages",
    "href": "blog/2023_12_12_select_empty_column'/select_empty_columns.html#load-packages",
    "title": "Select Empty Columns",
    "section": "Load packages",
    "text": "Load packages\n\nlibrary(tidyverse)\n\n-- Attaching core tidyverse packages ------------------------ tidyverse 2.0.0 --\nv dplyr     1.1.0     v readr     2.1.4\nv forcats   1.0.0     v stringr   1.5.0\nv ggplot2   3.4.1     v tibble    3.2.0\nv lubridate 1.9.2     v tidyr     1.3.0\nv purrr     1.0.1     \n-- Conflicts ------------------------------------------ tidyverse_conflicts() --\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\ni Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors"
  },
  {
    "objectID": "blog/2023_12_12_select_empty_column'/select_empty_columns.html#read-data",
    "href": "blog/2023_12_12_select_empty_column'/select_empty_columns.html#read-data",
    "title": "Select Empty Columns",
    "section": "Read data",
    "text": "Read data\n\nbillboard\n\n# A tibble: 317 x 79\n   artist track date.ent~1   wk1   wk2   wk3   wk4   wk5   wk6   wk7   wk8   wk9\n   &lt;chr&gt;  &lt;chr&gt; &lt;date&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 2 Pac  Baby~ 2000-02-26    87    82    72    77    87    94    99    NA    NA\n 2 2Ge+h~ The ~ 2000-09-02    91    87    92    NA    NA    NA    NA    NA    NA\n 3 3 Doo~ Kryp~ 2000-04-08    81    70    68    67    66    57    54    53    51\n 4 3 Doo~ Loser 2000-10-21    76    76    72    69    67    65    55    59    62\n 5 504 B~ Wobb~ 2000-04-15    57    34    25    17    17    31    36    49    53\n 6 98^0   Give~ 2000-08-19    51    39    34    26    26    19     2     2     3\n 7 A*Tee~ Danc~ 2000-07-08    97    97    96    95   100    NA    NA    NA    NA\n 8 Aaliy~ I Do~ 2000-01-29    84    62    51    41    38    35    35    38    38\n 9 Aaliy~ Try ~ 2000-03-18    59    53    38    28    21    18    16    14    12\n10 Adams~ Open~ 2000-08-26    76    76    74    69    68    67    61    58    57\n# ... with 307 more rows, 67 more variables: wk10 &lt;dbl&gt;, wk11 &lt;dbl&gt;,\n#   wk12 &lt;dbl&gt;, wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;,\n#   wk18 &lt;dbl&gt;, wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, wk23 &lt;dbl&gt;,\n#   wk24 &lt;dbl&gt;, wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, wk28 &lt;dbl&gt;, wk29 &lt;dbl&gt;,\n#   wk30 &lt;dbl&gt;, wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, wk34 &lt;dbl&gt;, wk35 &lt;dbl&gt;,\n#   wk36 &lt;dbl&gt;, wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;, wk40 &lt;dbl&gt;, wk41 &lt;dbl&gt;,\n#   wk42 &lt;dbl&gt;, wk43 &lt;dbl&gt;, wk44 &lt;dbl&gt;, wk45 &lt;dbl&gt;, wk46 &lt;dbl&gt;, wk47 &lt;dbl&gt;, ...\n\n\nWe will create an empty column in this table to reference it and find it."
  },
  {
    "objectID": "blog/2023_12_12_select_empty_column'/select_empty_columns.html#create-empty-column",
    "href": "blog/2023_12_12_select_empty_column'/select_empty_columns.html#create-empty-column",
    "title": "Select Empty Columns",
    "section": "Create empty column",
    "text": "Create empty column\n\nbillboard_modified &lt;- billboard |&gt; \n  mutate(\n    empty_col = NA_character_ #empty column\n  )"
  },
  {
    "objectID": "blog/2023_12_12_select_empty_column'/select_empty_columns.html#show-select-just-the-blank-or-empty-columns",
    "href": "blog/2023_12_12_select_empty_column'/select_empty_columns.html#show-select-just-the-blank-or-empty-columns",
    "title": "Select Empty Columns",
    "section": "Show / select just the blank or empty columns",
    "text": "Show / select just the blank or empty columns\n\nbillboard_modified |&gt; \n  select(where( ~ all(is.na(.))))\n\n# A tibble: 317 x 12\n   wk66  wk67  wk68  wk69  wk70  wk71  wk72  wk73  wk74  wk75  wk76  empty_col\n   &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;chr&gt;    \n 1 NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    &lt;NA&gt;     \n 2 NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    &lt;NA&gt;     \n 3 NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    &lt;NA&gt;     \n 4 NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    &lt;NA&gt;     \n 5 NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    &lt;NA&gt;     \n 6 NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    &lt;NA&gt;     \n 7 NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    &lt;NA&gt;     \n 8 NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    &lt;NA&gt;     \n 9 NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    &lt;NA&gt;     \n10 NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    &lt;NA&gt;     \n# ... with 307 more rows\n\n\nWe will use colnames() function to show the list of columns since this table has multiple empty columns.\n\nbillboard_modified |&gt; \n  select(where( ~ all(is.na(.)))) |&gt; \n  colnames()\n\n [1] \"wk66\"      \"wk67\"      \"wk68\"      \"wk69\"      \"wk70\"      \"wk71\"     \n [7] \"wk72\"      \"wk73\"      \"wk74\"      \"wk75\"      \"wk76\"      \"empty_col\"\n\n\nAs you can see it is very easy to find empty columns in a table."
  }
]